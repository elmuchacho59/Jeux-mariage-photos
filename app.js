const i18n = {
  fr: {
    unassigned: "Non assignÃ©",
    mission: "Mission",
    challenge: "DÃ©fi",
    welcome: "Bienvenue",
    chooseMissions: "Choisis tes missions âœ¨",
    missionsSaved: "Missions enregistrÃ©es. Tu peux envoyer tes photos.",
    selectTwoMissions: "Choisissez deux missions distinctes.",
    submitConfirmation: "Merci pour ta participation !",
    uploadBothPhotos: "Veuillez tÃ©lÃ©verser les deux photos avant d'envoyer.",
    photoSaved: "Photo enregistrÃ©e",
    imageProcessingError: "Impossible de traiter l'image.",
    adminPinIncorrect: "Code incorrect",
    adminDisconnected: "DÃ©connectÃ© de l'espace Admin.",
    dataCleared: "DonnÃ©es rÃ©initialisÃ©es",
    frameSaved: "Cadre enregistrÃ© !",
    frameDeleted: "Cadre supprimÃ©.",
    selectFile: "Veuillez sÃ©lectionner un fichier.",
    challengesUpdated: "DÃ©fis mis Ã  jour",
    atLeast3Missions: "Veuillez renseigner au moins 3 missions.",
    guestNameRequired: "Nom requis",
    missionsSavedSuccess: "Missions enregistrÃ©es",
    accessModeUpdated: "Mode d'accÃ¨s mis Ã  jour",
    eventPasswordUpdated: "Mot de passe Ã©vÃ¨nement mis Ã  jour",
    eventPasswordRequired: "Veuillez saisir un mot de passe Ã©vÃ¨nement.",
    settingsReset: "ParamÃ¨tres rÃ©initialisÃ©s",
    allPhotosDeleted: "Toutes les photos ont Ã©tÃ© supprimÃ©es",
    missionsReset: "Missions rÃ©initialisÃ©es",
    passwordIncorrect: "Mot de passe incorrect",
    guestAccessOnly: "AccÃ¨s rÃ©servÃ© aux invitÃ©s. Nom introuvable.",
    enterGuestName: "Veuillez saisir le nom de l'invitÃ©.",
    passwordHint: "Indice mot de passe: ta date de naissance au format JJ/MM/AAAA (ex: 01/01/1990).",
    eventPasswordHint: "Demandez le mot de passe de l'Ã©vÃ¨nement aux organisateurs.",
    cameraApiUnavailable: "L'API de la camÃ©ra n'est pas disponible sur ce navigateur.",
    cameraError: "Impossible d'ouvrir la camÃ©ra. Avez-vous donnÃ© l'autorisation?",
    captureImpossible: "Capture impossible",
    copiedToClipboard: "CopiÃ© dans le presse-papiers",
    noPublishedPhotos: "Aucune photo publiÃ©e.",
    deleteGuestConfirmation: "Supprimer cet invitÃ© ?",
    editGuestNamePrompt: "Nom de l'invitÃ©",
    editGuestPasswordPrompt: "Mot de passe (laisser vide pour aucun)",
    deleteAllDataConfirmation: "Tout effacer (assignations, noms, photos) sur cet appareil ?",
    resetSettingsConfirmation: "RÃ©initialiser les paramÃ¨tres par dÃ©faut (dÃ©fis, accÃ¨s invitÃ©s, mot de passe Ã©vÃ¨nement) ?",
    deleteAllPhotosConfirmation: "Supprimer TOUTES les photos ? Cette action est irrÃ©versible.",
    deletePhotoConfirmation: "Supprimer cette photo ?",
    enterMissionInstruction: "Saisir la consigne de la mission",
    missions: "Missions",
    mission1: "Mission 1",
    mission2: "Mission 2",
    challenge1: "DÃ©fi 1",
    challenge2: "DÃ©fi 2",
    pendingStatus: "En attente",
    publishedStatus: "PubliÃ©e",
    validateAndPublish: "Valider et Publier",
    delete: "Supprimer",
    edit: "Ã‰diter",
    validatedStatus: "âœ… 2/2 validÃ©s",
    inProgressStatus: "â³ en cours",
    likeLabel: "J'aime",
    cancel: "Annuler",
    takePhoto: "Prendre la photo",
    cameraErrorPrompt: "Erreur camÃ©ra:",
    galleryEmpty: "L'album est encore vide !",
    galleryEmptySubtitle: "ChÃ¨res invitÃ©es, Ã  vos appareils photo ! La galerie attend vos chefs-d'Å“uvre. ðŸ“¸",
    missionHeader: "Mission",
    challengeCompleted: "Bravo ! DÃ©fi rÃ©alisÃ© en",
  },
  es: {
    unassigned: "Sin asignar",
    mission: "MisiÃ³n",
    challenge: "Reto",
    welcome: "Â¡Bienvenido(a)!",
    chooseMissions: "Elige tus misiones âœ¨",
    missionsSaved: "Misiones guardadas. Ya puedes subir tus fotos.",
    selectTwoMissions: "Elige dos misiones distintas.",
    submitConfirmation: "Â¡Gracias por participar!",
    uploadBothPhotos: "Por favor, sube las dos fotos antes de enviar.",
    photoSaved: "Foto guardada",
    imageProcessingError: "No se pudo procesar la imagen.",
    adminPinIncorrect: "CÃ³digo incorrecto",
    adminDisconnected: "Desconectado del Ã¡rea de Admin.",
    dataCleared: "Datos restablecidos",
    frameSaved: "Â¡Marco guardado!",
    frameDeleted: "Marco eliminado.",
    selectFile: "Por favor, selecciona un archivo.",
    challengesUpdated: "Retos actualizados",
    atLeast3Missions: "Por favor, introduce al menos 3 misiones.",
    guestNameRequired: "Nombre requerido",
    missionsSavedSuccess: "Misiones guardadas",
    accessModeUpdated: "Modo de acceso actualizado",
    eventPasswordUpdated: "ContraseÃ±a del evento actualizada",
    eventPasswordRequired: "Por favor, introduce la contraseÃ±a del evento.",
    settingsReset: "ConfiguraciÃ³n restablecida",
    allPhotosDeleted: "Todas las fotos han sido eliminadas",
    missionsReset: "Misiones reiniciadas",
    passwordIncorrect: "ContraseÃ±a incorrecta",
    guestAccessOnly: "Acceso solo para invitados. Nombre no encontrado.",
    enterGuestName: "Por favor, introduce el nombre del invitado.",
    passwordHint: "Pista de la contraseÃ±a: tu fecha de nacimiento en formato DD/MM/AAAA (ej: 01/01/1990).",
    eventPasswordHint: "Pide la contraseÃ±a del evento a los organizadores.",
    cameraApiUnavailable: "La API de la cÃ¡mara no estÃ¡ disponible en este navegador.",
    cameraError: "No se puede abrir la cÃ¡mara. Â¿Has dado permiso?",
    captureImpossible: "Captura imposible",
    copiedToClipboard: "Copiado al portapapeles",
    noPublishedPhotos: "No hay fotos publicadas.",
    deleteGuestConfirmation: "Â¿Eliminar a este invitado?",
    editGuestNamePrompt: "Nombre del invitado",
    editGuestPasswordPrompt: "ContraseÃ±a (dejar en blanco para ninguna)",
    deleteAllDataConfirmation: "Â¿Borrar todos los datos (asignaciones, nombres, fotos) de este dispositivo?",
    resetSettingsConfirmation: "Â¿Restablecer la configuraciÃ³n predeterminada (retos, acceso de invitados, contraseÃ±a del evento)?",
    deleteAllPhotosConfirmation: "Â¿Eliminar TODAS las fotos? Esta acciÃ³n es irreversible.",
    deletePhotoConfirmation: "Â¿Eliminar esta foto?",
    enterMissionInstruction: "Introduce la consigna de la misiÃ³n",
    missions: "Misiones",
    mission1: "MisiÃ³n 1",
    mission2: "MisiÃ³n 2",
    challenge1: "Reto 1",
    challenge2: "Reto 2",
    pendingStatus: "Pendiente",
    publishedStatus: "Publicada",
    validateAndPublish: "Validar y Publicar",
    delete: "Eliminar",
    edit: "Editar",
    validatedStatus: "âœ… 2/2 validados",
    inProgressStatus: "â³ en curso",
    likeLabel: "Me gusta",
    cancel: "Cancelar",
    takePhoto: "Tomar la foto",
    cameraErrorPrompt: "Error de cÃ¡mara:",
    galleryEmpty: "Â¡El Ã¡lbum todavÃ­a estÃ¡ vacÃ­o!",
    galleryEmptySubtitle: "Â¡Queridos invitados, a sus cÃ¡maras! La galerÃ­a espera sus obras maestras. ðŸ“¸",
    missionHeader: "MisiÃ³n",
    challengeCompleted: "Â¡Bravo! Reto completado en",
  }
};

const lang = document.documentElement.lang === 'es' ? 'es' : 'fr';
const t = (key) => i18n[lang][key] || i18n.fr[key];

const SUPABASE_URL = "https://uiraepbmqeuqkaxpupct.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVpcmFlcGJtcWV1cWtheHB1cGN0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUyNjI4MDAsImV4cCI6MjA3MDgzODgwMH0.RtbVxvVfT0OFq209lPMvHR7k4_h2weAfnig7ahrFFpw";
const { createClient } = window.supabase;
const supabase_client = createClient(SUPABASE_URL, SUPABASE_KEY);

/*
  DÃ©fi Photo â€“ Mariage
  Application statique qui assigne 2 dÃ©fis photo distincts par invitÃ© via une roue de la fortune.
  - DonnÃ©es stockÃ©es localement dans localStorage
  - Fonctionne hors ligne
*/

const DEFAULT_CHALLENGES_FR = [
  "Un selfie avec les mariÃ©s",
  "Une photo d'un fou rire",
  "La plus belle danse",
  "Un bisous volÃ©",
  "Un toast levÃ©",
  "Les chaussures les plus stylÃ©es",
  "Un cÃ¢lin collectif",
  "Un dÃ©tail de dÃ©coration",
  "Le plus beau sourire",
  "Un moment inattendu",
  "Une photo en noir et blanc",
  "Un plan large de la salle",
  "Une photo avec un inconnu",
  "Les alliances en gros plan",
  "Les mains des invitÃ©s",
  "Un regard complice",
  "Un enfant qui s'amuse",
  "Un plat qui donne faim",
  "Une blague immortalisÃ©e",
  "Le bouquet sous un autre angle"
];

const DEFAULT_CHALLENGES_ES = [
    "Un selfie con los novios",
    "Una foto de una carcajada",
    "El baile mÃ¡s bonito",
    "Un beso robado",
    "Un brindis",
    "Los zapatos mÃ¡s estilosos",
    "Un abrazo grupal",
    "Un detalle de la decoraciÃ³n",
    "La sonrisa mÃ¡s bonita",
    "Un momento inesperado",
    "Una foto en blanco y negro",
    "Un plano general del salÃ³n",
    "Una foto con un desconocido",
    "Los anillos en primer plano",
    "Las manos de los invitados",
    "Una mirada cÃ³mplice",
    "Un niÃ±o divirtiÃ©ndose",
    "Un plato que da hambre",
    "Una broma inmortalizada",
    "El ramo desde otro Ã¡ngulo"
];

const DEFAULT_CHALLENGES = lang === 'es' ? DEFAULT_CHALLENGES_ES : DEFAULT_CHALLENGES_FR;

const STORAGE_KEY = "defis_mariage_assignations_v1"; // preserve existing data
const ADMIN_PASS_KEY = "defis_mariage_admin_enabled"; // simple toggle for admin access if needed later
const ADMIN_PIN_KEY = "defis_mariage_admin_pin";
const ADMIN_PIN_VALUE = "0105";
const STORAGE_NAME_KEY = "defis_mariage_invite_names_v1"; // map key->display name

const CHALLENGES_KEY = "defis_mariage_challenges_v1";
const GUESTS_KEY = "defis_mariage_guests_v1"; // { key: { display, password? } }
const ACCESS_MODE_KEY = "defis_mariage_access_mode_v1"; // 'all' | 'guests_only'
const EVENT_PASS_KEY = "defis_mariage_event_pass_v1"; // { required: boolean, password: string }
const MISSIONS_KEY = "defis_mariage_missions_v1"; // {1:{c1,c2},...,10:{c1,c2}}
const FRAME_KEY = "defis_mariage_frame_v1";

const state = {
  currentInviteName: null,
  currentRotationDeg: 0,
  isSpinning: false,
  challenges: [],
  assignments: {},
  nameMap: {},
  guests: {},
  accessMode: 'all',
  eventAccess: { required: false, password: '' },
  missions: {},
  frame: null,
};

async function loadInitialData() {
  state.challenges = await loadChallenges();
  state.assignments = await loadAssignments();
  state.nameMap = await loadNameMap();
  state.guests = await loadGuests();
  state.accessMode = await loadAccessMode();
  state.eventAccess = await loadEventPass();
  state.missions = await loadMissions();
  state.frame = localStorage.getItem(FRAME_KEY) || null; // Frame is local for now
}

let guestFlowSection, stepWelcome, stepMissions, stepConfirmation, missionSelectionPanel, missionDisplayPanel, confirmationGalleryBtn, confirmationNewGuestBtn, currentInviteEl, assignedCountEl, assignedItemsEl, challengeListEl, mission1El, mission2El, missionConfirmBtn, missionResetBtn, missionsTbody, missionsSaveBtn, missionConsignesCard, missionConsignesList, accessBannerEl, invitePassInput, invitePassRow, inviteNamesDatalist, eventPassRow, eventPassInput, spinBtn, lockedNoteEl, progressBarEl, toastContainer, confettiCanvas, goAdminBtn, goGalleryBtn, adminSection, adminExitBtn, gallerySection, galleryExitBtn, lightboxEl, lightboxBackdrop, lightboxImg, lightboxCaption, lightboxDownload, lightboxClose, adminRefreshBtn, adminCopyBtn, adminExportBtn, adminExportZipBtn, adminLogoutBtn, adminSearchInput, adminTbody, adminResetAllBtn, adminChallengesTextarea, adminChallengesSaveBtn, adminGuestName, adminGuestPass, adminGuestAddBtn, adminGuestsTbody, accessModeSelect, adminTabPending, adminTabPublished, adminPhotosPendingTbody, adminPhotosPublishedTbody, eventRequiredSelect, eventPassAdminInput, eventPassSaveBtn, adminResetSettingsBtn, adminDeleteAllPhotosBtn, uploadSection, submitMissionsBtn, submissionMsgEl, loadingOverlayEl;
let slotInputs = [], slotPreviews = [], slotZones = [], slotClears = [], slotLiveBtns = [], slotGalleryBtns = [];

const $ = (sel) => document.querySelector(sel);

function showLoading() { if (loadingOverlayEl) loadingOverlayEl.classList.remove('hidden'); }
function hideLoading() { if (loadingOverlayEl) loadingOverlayEl.classList.add('hidden'); }

async function loadAssignments() {
  const { data, error } = await supabase_client.from('assignments').select('*');
  if (error) {
    console.error('Error loading assignments:', error);
    return {};
  }
  const assignments = {};
  for (const assignment of data) {
    if (!assignments[assignment.invite_key]) {
      assignments[assignment.invite_key] = [];
    }
    assignments[assignment.invite_key].push(assignment.challenge);
  }
  return assignments;
}

async function loadChallenges() {
  const { data, error } = await supabase_client.from('challenges').select('text');
  if (error || !data || data.length === 0) {
    console.error('Error loading challenges, falling back to default:', error);
    return [...DEFAULT_CHALLENGES];
  }
  return data.map(c => c.text);
}

async function saveChallenges() {
  const challengesToSave = state.challenges.map(text => ({ text }));
  const { error } = await supabase_client.from('challenges').upsert(challengesToSave);
  if (error) {
    console.error('Error saving challenges:', error);
  }
}

async function saveAssignments() {
  const assignmentsToSave = [];
  for (const invite_key in state.assignments) {
    for (const challenge of state.assignments[invite_key]) {
      assignmentsToSave.push({ invite_key, challenge });
    }
  }
  // This is a bit simplistic, it will re-insert everything.
  // A better approach would be to only insert new assignments.
  // For now, we might need to clear and re-insert. Or use upsert carefully.
  // Let's clear first for simplicity.
  await supabase_client.from('assignments').delete().neq('invite_key', 'dummy_value_to_delete_all'); // hack to delete all
  const { error } = await supabase_client.from('assignments').insert(assignmentsToSave);
  if (error) {
    console.error('Error saving assignments:', error);
  }
}

async function loadNameMap() {
  // This is now part of the guests table, but we can still load it for legacy purposes
  // Or, more simply, derive it from the guests table.
  const { data, error } = await supabase_client.from('guests').select('key, display');
  if (error) {
    console.error('Error loading name map:', error);
    return {};
  }
  const nameMap = {};
  for (const guest of data) {
    nameMap[guest.key] = guest.display;
  }
  return nameMap;
}

async function saveNameMap() {
  // This is now handled by saveGuests, so this function can be a no-op
  // or be removed.
}

async function loadGuests() {
  const { data, error } = await supabase_client.from('guests').select('*');
  if (error) {
    console.error('Error loading guests:', error);
    return {};
  }
  const guests = {};
  for (const guest of data) {
    guests[guest.key] = { display: guest.display, password: guest.password };
  }
  return guests;
}
async function saveGuests() {
  const guestsToSave = Object.entries(state.guests).map(([key, { display, password }]) => ({ key, display, password }));
  const { error } = await supabase_client.from('guests').upsert(guestsToSave);
  if (error) {
    console.error('Error saving guests:', error);
  }
}

async function loadEventPass() {
    const { data, error } = await supabase_client.from('settings').select('value').eq('key', 'eventAccess').single();
    if (error || !data) {
        console.error('Error loading event pass:', error);
        return { required: false, password: '' };
    }
    return data.value;
}
async function saveEventPass() {
  const { error } = await supabase_client.from('settings').upsert({ key: 'eventAccess', value: state.eventAccess });
  if (error) {
    console.error('Error saving event pass:', error);
  }
}

async function loadMissions() {
  const { data, error } = await supabase_client.from('missions').select('*');
  if (error) {
    console.error('Error loading missions:', error);
    return {};
  }
  const missions = {};
  for (const mission of data) {
    missions[mission.id] = { fr: mission.fr, es: mission.es };
  }
  return missions;
}

async function saveMissions() {
  const missionsToSave = [];
  for (let i = 1; i <= 10; i++) {
    const fr = document.getElementById(`mission-c-${i}-fr`)?.value || '';
    const es = document.getElementById(`mission-c-${i}-es`)?.value || '';
    state.missions[i] = { fr, es };
    missionsToSave.push({ id: i, fr, es });
  }

  const { error } = await supabase_client.from('missions').upsert(missionsToSave);

  if (error) {
    console.error('Error saving missions:', error);
    showToast('Erreur lors de la sauvegarde des missions', 'danger');
  } else {
    showToast(t('missionsSavedSuccess'));
  }
}


async function loadAccessMode() {
  const { data, error } = await supabase_client.from('settings').select('value').eq('key', 'accessMode').single();
  if (error || !data) {
    console.error('Error loading access mode:', error);
    return 'all';
  }
  return data.value;
}
async function saveAccessMode() {
  const { error } = await supabase_client.from('settings').upsert({ key: 'accessMode', value: state.accessMode });
  if (error) {
    console.error('Error saving access mode:', error);
  }
}

function getAssignedForInvite(inviteName) {
  if (!inviteName) return [];
  const key = resolveInviteKey(inviteName);
  return state.assignments[key] || [];
}

function addAssignment(inviteName, challenge) {
  if (!inviteName || !challenge) return;
  const key = resolveInviteKey(inviteName);
  const current = state.assignments[key] || [];
  if (current.includes(challenge)) return;
  const updated = [...current, challenge];
  state.assignments[key] = updated;
  saveAssignments();
}

function clearAllAssignments() {
  state.assignments = {};
  saveAssignments();
  state.nameMap = {};
  saveNameMap();
}

function goToStep(stepId) {
    [stepWelcome, stepMissions, stepConfirmation].forEach(step => {
        if(step) step.classList.toggle('active', step.id === stepId);
    });
    if (adminSection) adminSection.classList.add('hidden');
    if (gallerySection) gallerySection.classList.add('hidden');
    if (guestFlowSection) guestFlowSection.classList.remove('hidden');
}

function renderAssigned(inviteName) {
  const assigned = getAssignedForInvite(inviteName);
  assignedCountEl.textContent = String(assigned.length);
  
  const completed = assigned.length >= 2;

  missionDisplayPanel.classList.toggle('hidden', !completed);
  missionSelectionPanel.classList.toggle('hidden', completed);

  if (completed) {
    const [c1 = t("mission1"), c2 = t("mission2")] = assigned;
    const lbl0 = document.getElementById("slot0-label");
    const lbl1 = document.getElementById("slot1-label");
    if (lbl0) lbl0.textContent = c1 || t("challenge1");
    if (lbl1) lbl1.textContent = c2 || t("challenge2");

    if (missionConsignesList) {
        missionConsignesList.innerHTML = "";
        assigned.forEach((c) => {
            const li = document.createElement("li");
            li.textContent = c;
            missionConsignesList.appendChild(li);
        });
    }
  }
  
  loadUploadsForInvite(state.currentInviteName);
}

function setCurrentInvite(name) {
  const display = String(name).trim();
  const key = resolveInviteKey(display);
  state.currentInviteName = key;
  state.nameMap[key] = display;
  // saveNameMap(); // This is no longer needed, guest is saved in startForInvite
  currentInviteEl.textContent = display;
  renderAssigned(key);
}

async function startForInvite(name) {
  if (!name || !name.trim()) {
    showToast(t("enterGuestName"), "danger");
    return;
  }

  const displayName = name.trim();
  const inviteKey = resolveInviteKey(displayName);

  // First, ensure the guest exists in the database.
  const { error: guestError } = await supabase_client
    .from('guests')
    .upsert({ key: inviteKey, display: displayName }, { onConflict: 'key' });

  if (guestError) {
    console.error('Error saving guest:', guestError);
    showToast("Erreur lors de l'enregistrement de l'invitÃ©.", 'danger');
    return;
  }

  // Then, perform other checks as before.
  if (state.accessMode === 'guests_only') {
    const guest = state.guests[inviteKey];
    if (!guest) {
      showToast(t("guestAccessOnly"), "danger");
      return;
    }
    if (guest && guest.password) {
      const pin = (invitePassInput && invitePassInput.value) || '';
      if (pin !== guest.password) {
        showToast(t("passwordIncorrect"), "danger");
        if (invitePassInput) {
          invitePassInput.focus();
          invitePassInput.classList.add('is-invalid');
          setTimeout(()=> invitePassInput.classList.remove('is-invalid'), 1500);
        }
        return;
      }
    }
  }
  if (state.eventAccess && state.eventAccess.required) {
    const pin = (eventPassInput && eventPassInput.value) || '';
    if (pin !== state.eventAccess.password) {
      showToast(t("passwordIncorrect"), "danger");
      if (eventPassInput) {
        eventPassInput.focus();
        eventPassInput.classList.add('is-invalid');
        setTimeout(()=> eventPassInput.classList.remove('is-invalid'), 1500);
      }
      return;
    }
  }

  goToStep('step-missions');
  setCurrentInvite(displayName);
  showToast(`${t('welcome')} ${displayName}! ${t('chooseMissions')}`);
}

function resetToInviteInput() {
  state.currentInviteName = null;
  const inviteInput = document.getElementById("invite-name");
  if(inviteInput) inviteInput.value = "";
  
  goToStep('step-welcome');

  missionSelectionPanel.classList.remove('hidden');
  missionDisplayPanel.classList.add('hidden');
  if (mission1El) { mission1El.selectedIndex = 0; }
  if (mission2El) { mission2El.selectedIndex = 0; }
  
  clearSlot(0);
  clearSlot(1);
}

function onConfirmMissions() {
  const invite = state.currentInviteName; if (!invite) return;
  const num1 = parseInt(mission1El.value, 10);
  const num2 = parseInt(mission2El.value, 10);
  if (Number.isNaN(num1) || Number.isNaN(num2) || num1 === num2) { 
    showToast(t('selectTwoMissions'), 'danger'); 
    return; 
  }
  const m1 = state.missions[num1] ? state.missions[num1][lang] : '';
  const m2 = state.missions[num2] ? state.missions[num2][lang] : '';
  const sel = [
    `${t('mission')} ${num1}: ${m1}`,
    `${t('mission')} ${num2}: ${m2}`
  ];
  const already = new Set(getAssignedForInvite(invite));
  sel.forEach(c => { if (!already.has(c)) addAssignment(invite, c); });
  
  renderAssigned(invite);
  showToast(t('missionsSaved'));
  launchConfetti();
}

async function onSubmitMissions() {
    const inviteKey = state.currentInviteName;
    if (!inviteKey) return;

    const [upload1, upload2] = getUploadsForInvite(inviteKey);
    if (!upload1 || !upload1.data || !upload2 || !upload2.data) {
        showToast(t("uploadBothPhotos"), "danger");
        return;
    }

    showLoading();
    try {
        for (let i = 0; i < 2; i++) {
            const previewSrc = slotPreviews[i].src;
            setUploadForInvite(inviteKey, i, previewSrc);
        }
    } finally {
        hideLoading();
    }

    showToast(t("submitConfirmation"));
    goToStep('step-confirmation');
}

function renderMissionsTable() {
  if (!missionsTbody) return;
  missionsTbody.innerHTML = '';
  for (let i=1;i<=10;i++) {
    const tr = document.createElement('tr');
    const m = state.missions[i] || { fr: '', es: '' };
    tr.innerHTML = `<td>${i}</td>
      <td><input id="mission-c-${i}-fr" class="input" value="${escapeHtml(m.fr)}" placeholder="${t('enterMissionInstruction')} ${i} (FR)"/></td>
      <td><input id="mission-c-${i}-es" class="input" value="${escapeHtml(m.es)}" placeholder="${t('enterMissionInstruction')} ${i} (ES)"/></td>`;
    missionsTbody.appendChild(tr);
  }
}

function hydrateMissionSelectors() {
  if (!mission1El || !mission2El) return;
  const options = Array.from({length:10}, (_,k) => k+1).map(n => `<option value="${n}">${n}</option>`).join('');
  mission1El.innerHTML = options;
  mission2El.innerHTML = options;
}




function updateMissionUIForInvite(inviteName, completed, assigned) {
  if (mission1El) mission1El.disabled = !!completed;
  if (mission2El) mission2El.disabled = !!completed;
  if (missionConfirmBtn) missionConfirmBtn.disabled = !!completed;
}

function resolveInviteKey(name) {
  return String(name).trim().toLowerCase().replace(/\s+/g, ' ').replace(/[^a-z0-9 Ã Ã¢Ã¤Ã§Ã©Ã¨ÃªÃ«Ã®Ã¯Ã´Ã¶Ã¹Ã»Ã¼-]/gi, '');
}

function showToast(message, type = 'success') {
  if (!toastContainer) return;
  const div = document.createElement("div");
  div.className = `toast ${type}`;
  div.textContent = message;
  toastContainer.appendChild(div);
  setTimeout(() => {
    div.remove();
  }, 2800);
}

function launchConfetti() {
  const ctx = confettiCanvas.getContext("2d");
  const { innerWidth: w, innerHeight: h } = window;
  confettiCanvas.width = w; confettiCanvas.height = h;
  const particles = Array.from({ length: 150 }, () => ({
    x: Math.random() * w,
    y: -20 - Math.random() * h,
    r: 3 + Math.random() * 4,
    c: `hsl(${Math.floor(Math.random()*360)} 90% 60%)`,
    vy: 2 + Math.random() * 3,
    vx: -1 + Math.random() * 2,
  }));
  let frame = 0;
  const maxFrames = 120;
  function draw() {
    ctx.clearRect(0,0,w,h);
    for (const p of particles) {
      ctx.fillStyle = p.c;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
      p.x += p.vx; p.y += p.vy;
      if (p.y > h + 20) { p.y = -20; p.x = Math.random()*w; }
    }
    frame += 1;
    if (frame < maxFrames) requestAnimationFrame(draw);
    else { ctx.clearRect(0,0,w,h); }
  }
  draw();
}

function openAdmin() {
  try {
    const ok = sessionStorage.getItem(ADMIN_PIN_KEY) === 'ok';
    if (!ok) {
      const pin = prompt(t('enterAdminPin'));
      if (pin !== ADMIN_PIN_VALUE) { 
        showToast(t('adminPinIncorrect'), 'danger'); 
        return; 
      }
      sessionStorage.setItem(ADMIN_PIN_KEY, 'ok');
    }
  } catch {}
  guestFlowSection.classList.add("hidden");
  adminSection.classList.remove("hidden");
  renderAdminTable();
  renderMissionsTable();
  if (adminChallengesTextarea) {
    adminChallengesTextarea.value = state.challenges.join("\n");
  }
  renderRanking();
  renderGuests();
  bindAdminPhotoTabs();
  renderAdminPhotos();
  renderAdminStats();
}

function closeAdmin() {
  adminSection.classList.add("hidden");
  goToStep(state.currentInviteName ? 'step-missions' : 'step-welcome');
}

function openGallery() {
  guestFlowSection.classList.add('hidden');
  adminSection.classList.add('hidden');
  gallerySection.classList.remove('hidden');
  renderGallery();
}

function closeGallery() {
  gallerySection.classList.add('hidden');
  goToStep(state.currentInviteName ? 'step-missions' : 'step-welcome');
}

function renderAdminTable() {
  try {
    renderAdminPhotos();
    renderRanking();
  } catch (_) {
  }
}

function computeDurationMs(inviteKey) {
  const [u0, u1] = getUploadsForInvite(inviteKey);
  if (!u0 || !u1 || !u0.createdAt || !u1.createdAt || !u0.approvedAt || !u1.approvedAt) return null;
  const start = Math.min(u0.createdAt, u1.createdAt);
  const end = Math.max(u0.approvedAt, u1.approvedAt);
  return Math.max(0, end - start);
}

function formatDuration(ms) {
  if (ms == null) return 'â€”';
  const mins = Math.floor(ms / 60000);
  const secs = Math.floor((ms % 60000) / 1000);
  return `${mins}m${secs.toString().padStart(2,'0')}s`;
}

function renderRanking() {
  const tbody = document.getElementById('ranking-tbody');
  if (!tbody) return;
  const rows = Object.keys(state.assignments).map((key) => {
    const display = state.nameMap[key] || key;
    const d = computeDurationMs(key);
    return { key, display, d };
  }).filter(r => r.d != null).sort((a,b) => a.d - b.d);
  tbody.innerHTML = '';
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(r.display)}</td><td>${formatDuration(r.d)}</td>`;
    tbody.appendChild(tr);
  });
}

function escapeHtml(str) {
  return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;');
}

function copyAdminData() {
  const rows = [["InvitÃ©","Mission 1","Mission 2"]];
  for (const [name, arr] of Object.entries(state.assignments)) {
    const displayName = state.nameMap[name] || name;
    rows.push([displayName, arr[0]||"", arr[1]||""]);
  }
  const text = rows.map(r => r.join('\t')).join('\n');
  navigator.clipboard.writeText(text).then(() => showToast(t("copiedToClipboard")));
}

function exportCSV() {
  const rows = [["Invite","Mission1","Mission2","Photo1_statut","Photo2_statut"]];
  for (const [name, arr] of Object.entries(state.assignments)) {
    const displayName = state.nameMap[name] || name;
    const [u0,u1] = getUploadsForInvite(name);
    const st0 = u0 ? `${u0.approved?'approuvÃ©e':'en_attente'}/${u0.published?'publiÃ©e':'non_publiÃ©e'}` : '';
    const st1 = u1 ? `${u1.approved?'approuvÃ©e':'en_attente'}/${u1.published?'publiÃ©e':'non_publiÃ©e'}` : '';
    rows.push([displayName, arr[0]||"", arr[1]||"", st0, st1]);
  }
  const csv = rows.map(r => r.map(cell => '"' + String(cell).replaceAll('"','""') + '"').join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'assignations_defis.csv';
  a.click();
  URL.revokeObjectURL(url);
}

async function exportZipGallery() {
  const files = [];
  let idx = 1;
  for (const [inviteKey, arr] of Object.entries(uploads)) {
    const display = state.nameMap[inviteKey] || inviteKey;
    (arr || []).forEach((up, slot) => {
      if (up && up.data && up.published) {
        files.push({
          name: `gallery/${sanitizeFileName(display)}_${slot+1}.jpg`,
          dataUrl: up.data,
        });
        idx += 1;
      }
    });
  }
  if (files.length === 0) { showToast(t('noPublishedPhotos'), 'danger'); return; }

  const blobs = await Promise.all(files.map(f => dataUrlToUint8Array(f.dataUrl).then(bytes => ({ name: f.name, bytes }))));
  const zipBlob = buildZipBlob(blobs);
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'galerie_publiee.zip';
  a.click();
  URL.revokeObjectURL(url);
}

function sanitizeFileName(name) {
  return String(name).normalize('NFKD').replace(/[^\w\-\s\.]+/g,'').trim().replace(/\s+/g,'_');
}

function dataUrlToUint8Array(dataUrl) {
  return new Promise((resolve, reject) => {
    try {
      const base64 = dataUrl.split(',')[1];
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
      resolve(bytes);
    } catch (e) { reject(e); }
  });
}

function buildZipBlob(files) {
  const encoder = new TextEncoder();
  const fileRecords = [];
  let offset = 0;
  const chunks = [];

  function crc32(bytes) {
    let c = ~0;
    for (let i=0;i<bytes.length;i++) {
      c ^= bytes[i];
      for (let k=0;k<8;k++) c = (c >>> 1) ^ (0xEDB88320 & -(c & 1));
    }
    return ~c >>> 0;
  }

  for (const f of files) {
    const nameBytes = encoder.encode(f.name);
    const csum = crc32(f.bytes);
    const size = f.bytes.length;
    const lf = new DataView(new ArrayBuffer(30));
    let p = 0;
    lf.setUint32(p, 0x04034b50, true); p+=4;
    lf.setUint16(p, 20, true); p+=2;
    lf.setUint16(p, 0, true); p+=2;
    lf.setUint16(p, 0, true); p+=2;
    lf.setUint16(p, 0, true); p+=2;
    lf.setUint16(p, 0, true); p+=2;
    lf.setUint32(p, csum, true); p+=4;
    lf.setUint32(p, size, true); p+=4;
    lf.setUint32(p, size, true); p+=4;
    lf.setUint16(p, nameBytes.length, true); p+=2;
    lf.setUint16(p, 0, true); p+=2;
    chunks.push(new Uint8Array(lf.buffer));
    chunks.push(nameBytes);
    chunks.push(f.bytes);

    fileRecords.push({ nameBytes, csum, size, offset });
    offset += 30 + nameBytes.length + size;
  }

  const cdStart = offset;
  for (const r of fileRecords) {
    const cd = new DataView(new ArrayBuffer(46));
    let p = 0;
    cd.setUint32(p, 0x02014b50, true); p+=4;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 20, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, r.csum, true); p+=4;
    cd.setUint32(p, r.size, true); p+=4;
    cd.setUint32(p, r.size, true); p+=4;
    cd.setUint16(p, r.nameBytes.length, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint16(p, 0, true); p+=2;
    cd.setUint32(p, 0, true); p+=4;
    cd.setUint32(p, r.offset, true); p+=4;
    chunks.push(new Uint8Array(cd.buffer));
    chunks.push(r.nameBytes);
  }
  const cdEnd = offset = cdStart + fileRecords.reduce((sum, r) => sum + 46 + r.nameBytes.length, 0);

  const eocd = new DataView(new ArrayBuffer(22));
  let q = 0;
  eocd.setUint32(q, 0x06054b50, true); q+=4;
  eocd.setUint16(q, 0, true); q+=2;
  eocd.setUint16(q, 0, true); q+=2;
  eocd.setUint16(q, fileRecords.length, true); q+=2;
  eocd.setUint16(q, fileRecords.length, true); q+=2;
  eocd.setUint32(q, cdEnd - cdStart, true); q+=4;
  eocd.setUint32(q, cdStart, true); q+=4;
  eocd.setUint16(q, 0, true); q+=2;
  chunks.push(new Uint8Array(eocd.buffer));

  return new Blob(chunks, { type: 'application/zip' });
}

async function init() {
  await loadInitialData();

  const langFrBtn = document.getElementById('lang-fr');
  const langEsBtn = document.getElementById('lang-es');


  if (langFrBtn) {
    langFrBtn.addEventListener('click', () => {
      window.location.href = 'index.html';
    });
  }

  if (langEsBtn) {
    langEsBtn.addEventListener('click', () => {
      window.location.href = 'index.es.html';
    });
  }
  guestFlowSection = $("#guest-flow-section");
  stepWelcome = $("#step-welcome");
  stepMissions = $("#step-missions");
  stepConfirmation = $("#step-confirmation");
  missionSelectionPanel = $("#mission-selection-panel");
  missionDisplayPanel = $("#mission-display-panel");
  confirmationGalleryBtn = $("#confirmation-gallery-btn");
  confirmationNewGuestBtn = $("#confirmation-new-guest-btn");
  currentInviteEl = $("#current-invite");
  assignedCountEl = $("#assigned-count");
  assignedItemsEl = $("#assigned-items");
  challengeListEl = $("#challenge-list");
  mission1El = document.getElementById('mission1');
  mission2El = document.getElementById('mission2');
  missionConfirmBtn = document.getElementById('mission-confirm-btn');
  missionResetBtn = document.getElementById('mission-reset-btn');
  missionsTbody = document.getElementById('missions-tbody');
  missionsSaveBtn = document.getElementById('missions-save');
  missionConsignesCard = document.getElementById('mission-consignes');
  missionConsignesList = document.getElementById('mission-consignes-list');
  accessBannerEl = document.getElementById('access-banner');
  invitePassInput = document.getElementById('invite-pass');
  invitePassRow = document.getElementById('invite-pass-row');
  inviteNamesDatalist = document.getElementById('invite-names');
  eventPassRow = document.getElementById('event-pass-row');
  eventPassInput = document.getElementById('event-pass');
  spinBtn = $("#spin-btn");
  lockedNoteEl = $("#locked-note");
  progressBarEl = $("#progress-bar");
  toastContainer = $("#toast-container");
  confettiCanvas = $("#confetti-canvas");
  goAdminBtn = $("#go-admin-btn");
  goGalleryBtn = $("#go-gallery-btn");
  adminSection = $("#admin-section");
  adminExitBtn = $("#admin-exit");
  gallerySection = document.getElementById('gallery-section');
  galleryExitBtn = document.getElementById('gallery-exit');
  lightboxEl = document.getElementById('lightbox');
  lightboxBackdrop = document.getElementById('lightbox-backdrop');
  lightboxImg = document.getElementById('lightbox-img');
  lightboxCaption = document.getElementById('lightbox-caption');
  lightboxDownload = document.getElementById('lightbox-download');
  lightboxClose = document.getElementById('lightbox-close');
  adminRefreshBtn = $("#admin-refresh");
  adminCopyBtn = $("#admin-copy");
  adminExportBtn = $("#admin-export");
  adminExportZipBtn = $("#admin-export-zip");
  adminLogoutBtn = $("#admin-logout");
  adminSearchInput = $("#admin-search");
  adminTbody = $("#admin-tbody");
  adminResetAllBtn = $("#admin-reset-all");
  
  adminGuestName = $("#admin-guest-name");
  adminGuestPass = $("#admin-guest-pass");
  adminGuestAddBtn = $("#admin-guest-add");
  adminGuestsTbody = $("#admin-guests-tbody");
  accessModeSelect = $("#access-mode");
  adminTabPending = $("#admin-tab-pending");
  adminTabPublished = $("#admin-tab-published");
  adminPhotosPendingTbody = $("#admin-photos-pending-tbody");
  adminPhotosPublishedTbody = $("#admin-photos-published-tbody");
  eventRequiredSelect = document.getElementById('event-required');
  eventPassAdminInput = document.getElementById('event-pass-admin');
  eventPassSaveBtn = document.getElementById('event-pass-save');
  adminResetSettingsBtn = document.getElementById('admin-reset-settings');
  adminDeleteAllPhotosBtn = document.getElementById('admin-delete-all-photos');
  uploadSection = $("#upload-section");
  slotInputs = [$("#slot0-input"), $("#slot1-input")];
  slotPreviews = [$("#slot0-preview"), $("#slot1-preview")];
  slotZones = [$("#slot0-zone"), $("#slot1-zone")];
  slotClears = [$("#slot0-clear"), $("#slot1-clear")];
  slotLiveBtns = [document.getElementById('slot0-live-btn'), document.getElementById('slot1-live-btn')];
  slotGalleryBtns = [document.getElementById('slot0-gallery-btn'), document.getElementById('slot1-gallery-btn')];
  submitMissionsBtn = document.getElementById('submit-missions-btn');
  submissionMsgEl = document.getElementById('submission-msg');
  loadingOverlayEl = document.getElementById('loading-overlay');

  const startBtn = document.getElementById("start-btn");
  const inviteInput = document.getElementById("invite-name");
  const nextInviteBtn = document.getElementById("next-invite-btn");
  if (startBtn) startBtn.addEventListener("click", async () => startForInvite(inviteInput && inviteInput.value));
  if (inviteInput) inviteInput.addEventListener("keydown", async (e) => { if (e.key === "Enter") startForInvite(inviteInput.value); });
  if (nextInviteBtn) nextInviteBtn.addEventListener("click", () => resetToInviteInput());
  if (missionConfirmBtn) missionConfirmBtn.addEventListener('click', onConfirmMissions);
  if (missionResetBtn) missionResetBtn.addEventListener('click', () => {
    if (mission1El) { mission1El.selectedIndex = 0; }
    if (mission2El) { mission2El.selectedIndex = 0; }
    if (missionConsignesCard) { missionConsignesCard.classList.add('hidden'); if (missionConsignesList) missionConsignesList.innerHTML = ''; }
    showToast(t('missionsReset'));
  });

  if (goAdminBtn) goAdminBtn.addEventListener("click", openAdmin);
  if (goGalleryBtn) goGalleryBtn.addEventListener('click', openGallery);
  if (adminExitBtn) adminExitBtn.addEventListener("click", closeAdmin);
  if (galleryExitBtn) galleryExitBtn.addEventListener('click', closeGallery);
  if (adminRefreshBtn) adminRefreshBtn.addEventListener("click", renderAdminTable);
  if (adminCopyBtn) adminCopyBtn.addEventListener("click", () => { copyAdminData(); renderAdminPhotos(); });
  if (adminExportBtn) adminExportBtn.addEventListener("click", exportCSV);
  if (adminExportZipBtn) adminExportZipBtn.addEventListener("click", exportZipGallery);
  if (adminLogoutBtn) adminLogoutBtn.addEventListener('click', () => {
    try { sessionStorage.removeItem(ADMIN_PIN_KEY); } catch {}
    showToast(t('adminDisconnected'));
    closeAdmin();
  });
  if (adminSearchInput) adminSearchInput.addEventListener("input", renderAdminTable);
  if (adminResetAllBtn) adminResetAllBtn.addEventListener("click", () => {
    if (confirm(t("deleteAllDataConfirmation"))) {
      clearAllAssignments();
      clearAllUploads();
      renderAdminTable();
      showToast(t("dataCleared"));
    }
  });

  let frameUploadInput, frameSaveBtn, frameDeleteBtn, framePreviewImg;
  
  frameUploadInput = document.getElementById('frame-upload-input');
  frameSaveBtn = document.getElementById('frame-save-btn');
  frameDeleteBtn = document.getElementById('frame-delete-btn');
  framePreviewImg = document.getElementById('frame-preview-img');

  if (frameUploadInput && frameSaveBtn && frameDeleteBtn && framePreviewImg) {
    frameSaveBtn.addEventListener('click', () => {
      const file = frameUploadInput.files[0];
      if (!file) {
        showToast(t("selectFile"), "danger");
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        state.frame = e.target.result;
        localStorage.setItem(FRAME_KEY, state.frame);
        framePreviewImg.src = state.frame;
        showToast(t("frameSaved"));
      };
      reader.readAsDataURL(file);
    });

    frameDeleteBtn.addEventListener('click', () => {
      state.frame = null;
      localStorage.removeItem(FRAME_KEY);
      framePreviewImg.src = '';
      showToast(t("frameDeleted"));
    });

    if (state.frame) {
      framePreviewImg.src = state.frame;
    }
  }

  if (missionsSaveBtn) missionsSaveBtn.addEventListener('click', saveMissions);

  if (accessModeSelect) {
    accessModeSelect.value = state.accessMode;
    accessModeSelect.addEventListener('change', () => {
      state.accessMode = accessModeSelect.value; saveAccessMode();
      showToast(t("accessModeUpdated"));
    });
  }

  if (eventRequiredSelect && eventPassAdminInput && eventPassSaveBtn) {
    eventRequiredSelect.value = state.eventAccess.required ? 'yes' : 'no';
    eventPassAdminInput.value = state.eventAccess.password || '';
    eventPassSaveBtn.addEventListener('click', () => {
      const required = (eventRequiredSelect.value === 'yes');
      const pwd = (eventPassAdminInput.value || '').trim();
      if (required && !pwd) { 
        showToast(t('eventPasswordRequired'), 'danger'); 
        return; 
      }
      state.eventAccess.required = required;
      state.eventAccess.password = pwd;
      saveEventPass();
      if (eventPassRow) eventPassRow.classList.toggle('hidden', !required);
      if (!required && eventPassInput) {
        eventPassInput.value = '';
        eventPassInput.classList.remove('is-valid','is-invalid');
      }
      showToast(t('eventPasswordUpdated'));
    });
  }

  const adminPhotoSort = document.getElementById('admin-photo-sort');
  if (adminPhotoSort) adminPhotoSort.addEventListener('change', renderAdminPhotos);

  if (adminResetSettingsBtn) adminResetSettingsBtn.addEventListener('click', () => {
    if (!confirm(t('resetSettingsConfirmation'))) return;
    state.challenges = [...DEFAULT_CHALLENGES]; saveChallenges();
    state.accessMode = 'all'; saveAccessMode();
    state.eventAccess = { required: false, password: '' }; saveEventPass();
    if (adminChallengesTextarea) adminChallengesTextarea.value = state.challenges.join('\n');
    if (accessModeSelect) accessModeSelect.value = 'all';
    if (eventRequiredSelect) eventRequiredSelect.value = 'no';
    if (eventPassAdminInput) eventPassAdminInput.value = '';
    if (eventPassRow) eventPassRow.classList.add('hidden');
    showToast(t('settingsReset'));
  });

  if (adminDeleteAllPhotosBtn) adminDeleteAllPhotosBtn.addEventListener('click', () => {
    if (!confirm(t('deleteAllPhotosConfirmation'))) return;
    uploads = {}; saveUploads();
    renderAdminPhotos();
    showToast(t('allPhotosDeleted'));
  });

  renderGallery();
  
  hydrateMissionSelectors();

  if (accessBannerEl) {
    accessBannerEl.classList.toggle('hidden', state.accessMode !== 'guests_only');
  }

  if (inviteNamesDatalist) {
    inviteNamesDatalist.innerHTML = '';
    if (state.accessMode === 'guests_only') {
      Object.values(state.guests).forEach(g => {
        const opt = document.createElement('option');
        opt.value = g.display;
        inviteNamesDatalist.appendChild(opt);
      });
    }
  }

  const inviteInputEl = document.getElementById('invite-name');
  if (inviteInputEl) {
    inviteInputEl.addEventListener('input', () => {
      if (state.accessMode !== 'guests_only') { if(invitePassRow) invitePassRow.classList.add('hidden'); return; }
      const key = resolveInviteKey(inviteInputEl.value||'');
      const guest = state.guests[key];
      const needPass = !!(guest && guest.password);
      if (invitePassRow) invitePassRow.classList.toggle('hidden', !needPass);
    });
  }

  const passHelpBtn = document.getElementById('invite-pass-help');
  if (passHelpBtn) passHelpBtn.addEventListener('click', ()=> showToast(t('passwordHint')));
  const passToggleBtn = document.getElementById('invite-pass-toggle');
  if (passToggleBtn && invitePassInput) passToggleBtn.addEventListener('click', ()=> {
    const isText = invitePassInput.type === 'text';
    invitePassInput.type = isText ? 'password' : 'text';
    passToggleBtn.setAttribute('aria-pressed', String(!isText));
  });

  if (eventPassRow) eventPassRow.classList.toggle('hidden', !(state.eventAccess && state.eventAccess.required));
  const eventHelpBtn = document.getElementById('event-pass-help');
  if (eventHelpBtn) eventHelpBtn.addEventListener('click', ()=> showToast(t('eventPasswordHint')));
  const eventToggleBtn = document.getElementById('event-pass-toggle');
  if (eventToggleBtn && eventPassInput) eventToggleBtn.addEventListener('click', ()=> {
    const isText = eventPassInput.type === 'text';
    eventPassInput.type = isText ? 'password' : 'text';
    eventToggleBtn.setAttribute('aria-pressed', String(!isText));
  });

  if (eventPassInput) eventPassInput.addEventListener('input', ()=> {
    if (!(state.eventAccess && state.eventAccess.required)) return;
    const ok = eventPassInput.value === (state.eventAccess.password||'');
    eventPassInput.classList.toggle('is-valid', ok);
    eventPassInput.classList.toggle('is-invalid', !ok && eventPassInput.value.length>0);
  });
  if (invitePassInput) invitePassInput.addEventListener('input', ()=> {
    if (state.accessMode !== 'guests_only') return;
    const nameEl = document.getElementById('invite-name');
    const key = resolveInviteKey((nameEl && nameEl.value)||'');
    const guest = state.guests[key];
    if (!(guest && guest.password)) return;
    const ok = invitePassInput.value === guest.password;
    invitePassInput.classList.toggle('is-valid', ok);
    invitePassInput.classList.toggle('is-invalid', !ok && invitePassInput.value.length>0);
  });

  slotInputs.forEach((input, i) => {
    if (!input) return;
    input.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (file) handleImageSelected(i, file);
    });
    const frameToggle = document.getElementById(`frame-toggle-input-${i}`);
    if (frameToggle) {
      frameToggle.addEventListener('change', () => updatePreview(i));
    }
  });

  slotLiveBtns.forEach((btn, i) => {
      if (!btn) return;
      btn.addEventListener('click', () => openLiveCapture(i));
  });

  slotGalleryBtns.forEach((btn, i) => {
      if (!btn) return;
      btn.addEventListener('click', () => slotInputs[i].click());
  });

  slotZones.forEach((zone, i) => {
    if (!zone) return;
    zone.addEventListener("dragover", (e) => { e.preventDefault(); zone.classList.add("dragover"); });
    zone.addEventListener("dragleave", () => zone.classList.remove("dragover"));
    zone.addEventListener("drop", (e) => {
      e.preventDefault(); zone.classList.remove("dragover");
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) handleImageSelected(i, file);
    });
  });
  slotClears.forEach((btn, i) => { if (btn) btn.addEventListener("click", () => clearSlot(i)); });

  if (submitMissionsBtn) submitMissionsBtn.addEventListener('click', onSubmitMissions);

  if (confirmationGalleryBtn) confirmationGalleryBtn.addEventListener('click', openGallery);
  if (confirmationNewGuestBtn) confirmationNewGuestBtn.addEventListener('click', resetToInviteInput);

  if (lightboxBackdrop) lightboxBackdrop.addEventListener('click', hideLightbox);
  if (lightboxClose) lightboxClose.addEventListener('click', hideLightbox);
  
}


function renderGuests() {
  if (!adminGuestsTbody) return;
  adminGuestsTbody.innerHTML = '';
  const entries = Object.entries(state.guests).sort(([a],[b]) => a.localeCompare(b));
  entries.forEach(([key, g]) => {
    const status = computeDurationMs(key) != null ? t('validatedStatus') : t('inProgressStatus');
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${escapeHtml(g.display||key)}</td>
      <td>${g.password ? 'â€¢â€¢â€¢â€¢' : 'â€”'}</td>
      <td>${status}</td>
      <td>
        <button class="btn" data-g="${key}" data-act="edit">${t('edit')}</button>
        <button class="btn danger" data-g="${key}" data-act="del">${t('delete')}</button>
      </td>`;
    adminGuestsTbody.appendChild(tr);
  });
  adminGuestsTbody.querySelectorAll('button[data-act="del"]').forEach(btn => {
    btn.addEventListener('click', () => {
      const k = btn.getAttribute('data-g');
      if (confirm(t('deleteGuestConfirmation'))) { delete state.guests[k]; saveGuests(); renderGuests(); }
    });
  });
  adminGuestsTbody.querySelectorAll('button[data-act="edit"]').forEach(btn => {
    btn.addEventListener('click', () => {
      const k = btn.getAttribute('data-g');
      const g = state.guests[k];
      const newName = prompt(t('editGuestNamePrompt'), g.display||'');
      if (!newName) return;
      const newPass = prompt(t('editGuestPasswordPrompt'), g.password||'');
      const newKey = resolveInviteKey(newName);
      delete state.guests[k];
      state.guests[newKey] = { display: newName, password: newPass||null };
      saveGuests(); renderGuests();
    });
  });
}

function bindAdminPhotoTabs() {
  if (!adminTabPending || !adminTabPublished) return;
  const views = {
    pending: document.getElementById('admin-photos-pending'),
    published: document.getElementById('admin-photos-published')
  };
  function activate(which) {
    adminTabPending.classList.toggle('active', which==='pending');
    adminTabPublished.classList.toggle('active', which==='published');
    if (views.pending) views.pending.classList.toggle('hidden', which!=='pending');
    if (views.published) views.published.classList.toggle('hidden', which!=='published');
  }
  adminTabPending.addEventListener('click', ()=> activate('pending'));
  adminTabPublished.addEventListener('click', ()=> activate('published'));
}

function renderAdminPhotos() {
  if (!adminPhotosPendingTbody || !adminPhotosPublishedTbody) return;
  adminPhotosPendingTbody.innerHTML = '';
  adminPhotosPublishedTbody.innerHTML = '';
  const fmt = (ts) => ts ? new Date(ts).toLocaleString() : 'â€”';
  const sortMode = (document.getElementById('admin-photo-sort')?.value) || 'date_desc';
  const records = [];
  for (const [inviteKey, arr] of Object.entries(uploads)) {
    const display = state.nameMap[inviteKey] || inviteKey;
    (arr||[]).forEach((up, slot) => {
      if (!up || !up.data) return;
      const id = makeImageId(inviteKey, up.data); const c = (likesDb[id]&&likesDb[id].count)||0;
      records.push({ inviteKey, slot, up, display, likes: c });
    });
  }
  console.log(`[renderAdminPhotos] Records to render:`, records);
  records.sort((a,b) => {
    if (sortMode === 'date_asc') return (a.up.createdAt||0) - (b.up.createdAt||0);
    if (sortMode === 'likes_desc') return (b.likes||0) - (a.likes||0);
    return (b.up.createdAt||0) - (a.up.createdAt||0);
  });
  for (const rec of records) {
    const { inviteKey, slot, up, display, likes } = rec;
    const tr = document.createElement('tr');
    const img = `<img src="${up.data}" alt="mini" style="width:56px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #e2e8f0;"/>`;
    if (!up.published) {
      tr.innerHTML = `<td>${img}</td><td>${escapeHtml(display)} <span class="status-badge status-pending">${t('pendingStatus')}</span></td><td>${escapeHtml(up.challengeLabel||'')}</td><td>${fmt(up.createdAt)}</td><td><button class="btn" data-act="publish" data-g="${inviteKey}" data-slot="${slot}">${t('validateAndPublish')}</button> <button class="btn danger" data-act="delete" data-g="${inviteKey}" data-slot="${slot}">${t('delete')}</button></td>`;
      adminPhotosPendingTbody.appendChild(tr);
    } else if (up.published) {
      tr.innerHTML = `<td>${img}</td><td>${escapeHtml(display)} <span class="status-badge status-published">${t('publishedStatus')}</span></td><td>${escapeHtml(up.challengeLabel||'')}</td><td>${fmt(up.publishedAt)}</td><td>${likes} â¤ï¸</td><td><button class="btn danger" data-act="delete" data-g="${inviteKey}" data-slot="${slot}">${t('delete')}</button></td>`;
      adminPhotosPublishedTbody.appendChild(tr);
    }
  }
  adminPhotosPendingTbody.querySelectorAll('button[data-act="publish"]').forEach(btn => {
    btn.addEventListener('click', () => {
      const g = btn.getAttribute('data-g'); const s = Number(btn.getAttribute('data-slot'));
      handleAdminActionOnUpload('publish', g, s);
      renderAdminPhotos();
    });
  });
  [adminPhotosPendingTbody, adminPhotosPublishedTbody].forEach(tbody => {
    tbody.querySelectorAll('button[data-act="delete"]').forEach(btn => {
      btn.addEventListener('click', () => {
        const g = btn.getAttribute('data-g'); const s = Number(btn.getAttribute('data-slot'));
        if (!confirm(t('deletePhotoConfirmation'))) return;
        const arr = uploads[g] || [null,null];
        arr[s] = null; uploads[g] = arr; saveUploads();
        renderAdminPhotos();
        showToast(t('photoDeleted'));
      });
    });
  });
}

const UPLOADS_KEY = "defis_mariage_uploads_v2";

async function loadUploads() {
  const { data, error } = await supabase_client.from('uploads').select('*');
  if (error) {
    console.error('Error loading uploads:', error);
    return {};
  }
  const uploads = {};
  for (const upload of data) {
    if (!uploads[upload.invite_key]) {
      uploads[upload.invite_key] = [];
    }
    uploads[upload.invite_key][upload.slot] = {
      data: upload.url,
      approved: upload.approved,
      published: upload.published,
      challengeLabel: upload.challenge_label,
      createdAt: new Date(upload.created_at).getTime(),
      approvedAt: upload.approved_at ? new Date(upload.approved_at).getTime() : null,
      publishedAt: upload.published_at ? new Date(upload.published_at).getTime() : null,
    };
  }
  return uploads;
}
let uploads = loadUploads();
async function saveUploads() {
  // This function will now be handled by more granular functions like setUploadForInvite
  // and handleAdminActionOnUpload, so we can leave it empty or remove it.
}

function getUploadsForInvite(inviteKey) {
  const entry = uploads[inviteKey];
  if (!entry) return [null, null];
  return [entry[0] || null, entry[1] || null];
}
async function setUploadForInvite(inviteKey, slot, dataUrl) {
  const fileName = `${inviteKey}-${slot}-${Date.now()}.jpg`;
  const { data, error } = await supabase_client.storage
    .from('photos')
    .upload(fileName, dataUrlToBlob(dataUrl), {
      contentType: 'image/jpeg',
      upsert: true,
    });

  if (error) {
    console.error('Error uploading file:', error);
    return;
  }

  const { publicURL, error: urlError } = supabase_client.storage.from('photos').getPublicUrl(fileName);

  if (urlError) {
    console.error('Error getting public URL:', urlError);
    return;
  }

  const challengeLabel = (getAssignedForInvite(inviteKey)[slot]) || (slot === 0 ? t('mission1') : t('mission2'));
  const { error: dbError } = await supabase_client.from('uploads').upsert({
    invite_key: inviteKey,
    slot,
    url: publicURL,
    challenge_label: challengeLabel,
    created_at: new Date(),
  }, { onConflict: 'invite_key, slot' });

  if (dbError) {
    console.error('Error saving upload metadata:', dbError);
  } else {
    // Manually update the local state for immediate UI feedback
    const current = uploads[inviteKey] || [null, null];
    current[slot] = { data: publicURL, approved: false, published: false, challengeLabel, createdAt: Date.now(), approvedAt: null, publishedAt: null };
    uploads[inviteKey] = current;
  }
}

function dataUrlToBlob(dataUrl) {
  const arr = dataUrl.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while(n--){
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], {type:mime});
}
async function clearAllUploads() {
  const { error } = await supabase_client.from('uploads').delete().neq('invite_key', 'dummy_value_to_delete_all'); // hack to delete all
  if (error) {
    console.error('Error clearing uploads:', error);
  } else {
    uploads = {};
  }
  // This doesn't delete files from storage, which might be desired.
}

function loadUploadsForInvite(inviteKey) {
  for (let i = 0; i < 2; i++) {
    updatePreview(i);
  }
  const [a,b] = getUploadsForInvite(inviteKey);
  if (submitMissionsBtn) {
      submitMissionsBtn.disabled = !(a && a.data && b && b.data);
  }
}

async function updatePreview(slot) {
  const [a, b] = getUploadsForInvite(state.currentInviteName);
  const arr = [a, b];
  const upload = arr[slot];
  const dataUrl = upload && upload.data;
  
  const imgPreview = slotPreviews[slot];
  const zone = slotZones[slot];
  const frameToggleWrapper = document.getElementById(`frame-toggle-wrapper-${slot}`);
  const frameToggle = document.getElementById(`frame-toggle-input-${slot}`);

  if (frameToggleWrapper) {
    frameToggleWrapper.classList.toggle('hidden', !state.frame || !dataUrl);
  }

  if (dataUrl) {
    const shouldUseFrame = frameToggle && frameToggle.checked && state.frame;
    imgPreview.src = shouldUseFrame ? await applyFrame(dataUrl) : dataUrl;
    imgPreview.classList.remove('hidden');
    zone.querySelector('.drop__hint').classList.add('hidden');
  } else {
    imgPreview.src = '';
    imgPreview.classList.add('hidden');
    zone.querySelector('.drop__hint').classList.remove('hidden');
  }
}

function clearSlot(i) {
  const key = state.currentInviteName;
  if (!key) return;
  const entry = uploads[key] || [null, null];
  entry[i] = null;
  uploads[key] = entry;
  saveUploads();
  loadUploadsForInvite(key);
}

async function handleImageSelected(slot, file) {
  showLoading();
  try {
    const dataUrl = await compressImageToDataUrl(file); // Just compress, don't frame yet
    const key = state.currentInviteName;
    if (!key) {
      console.warn(`[handleImageSelected] No current invite name. Cannot set upload.`);
      return;
    }
    setUploadForInvite(key, slot, dataUrl);
    await updatePreview(slot); // New function to handle preview with/without frame
    showToast(`${t('photoSaved')} ${slot+1}`);
    loadUploadsForInvite(key);
  } catch (e) {
    console.error(`[handleImageSelected] Error processing image:`, e);
    showToast(t("imageProcessingError"), "danger");
  } finally {
    hideLoading();
  }
}

function handleAdminActionOnUpload(action, inviteKey, slot) {
  const entry = uploads[inviteKey] || [null, null];
  const item = entry[slot];
  if (!item) return;
  if (action === 'publish') {
    item.approved = true;
    item.published = true;
    item.approvedAt = item.approvedAt || Date.now();
    item.publishedAt = Date.now();
  }
  uploads[inviteKey] = entry;
  saveUploads();
  renderAdminTable();
  renderGallery();
}

function renderGallery() {
  const columnsWrap = document.getElementById('gallery-columns');
  let placeholder = document.getElementById('gallery-placeholder');

  if (!columnsWrap) return; // Bail if the main container isn't there

  // If placeholder is missing from HTML (e.g., old cached version), create it dynamically
  if (!placeholder) {
    placeholder = document.createElement('div');
    placeholder.id = 'gallery-placeholder';
    placeholder.className = 'card card--light hidden'; // Start hidden
    placeholder.style.textAlign = 'center';
    placeholder.style.padding = '32px';
    placeholder.style.marginBottom = '12px';
    placeholder.innerHTML = `
      <h3>${t('galleryEmpty')}</h3>
      <p class="subtitle">${t('galleryEmptySubtitle')}</p>
    `;
    columnsWrap.parentNode.insertBefore(placeholder, columnsWrap);
  }

  columnsWrap.innerHTML = '';
  const byChallenge = new Map();
  for (const [inviteKey, arr] of Object.entries(uploads)) {
    const display = state.nameMap[inviteKey] || inviteKey;
    (arr || []).forEach((up) => {
      if (up && up.data && up.published) {
        const label = up.challengeLabel || t('mission');
        if (!byChallenge.has(label)) byChallenge.set(label, []);
        byChallenge.get(label).push({ img: up.data, label, invite: display, inviteKey });
      }
    });
  }
  
  if (byChallenge.size === 0) {
    placeholder.classList.remove('hidden');
    columnsWrap.classList.add('hidden');
    return;
  }
  
  placeholder.classList.add('hidden');
  columnsWrap.classList.remove('hidden');

  const labels = Array.from(byChallenge.keys()).sort();
  labels.forEach((label, idx) => {
    const col = document.createElement('div');
    col.className = 'gallery-column';
    col.innerHTML = `<h4>${t('missionHeader')} ${idx+1} â€“ ${escapeHtml(label)}</h4>`;
    const grid = document.createElement('div');
    grid.className = 'gallery-grid';
    byChallenge.get(label).forEach(({ img, invite, inviteKey }) => {
      const div = document.createElement('div');
      div.className = 'gallery-item';
      const likes = getLikesFor(inviteKey, img);
      let timeInfo = '';
      const [u0,u1] = getUploadsForInvite(inviteKey);
      const uploadsTimes = [u0&&u0.createdAt, u1&&u1.createdAt].filter(Boolean);
      const approvedTimes = [u0&&u0.approvedAt, u1&&u1.approvedAt].filter(Boolean);
      if (uploadsTimes.length === 2 && approvedTimes.length === 2) {
        const start = Math.min(...uploadsTimes);
        const end = Math.max(...approvedTimes);
        const ms = Math.max(0, end - start);
        const mins = Math.floor(ms/60000); const secs = Math.floor((ms%60000)/1000);
        timeInfo = `${t('challengeCompleted')} ${mins}m${secs.toString().padStart(2,'0')}s ðŸŽ¯`;
      }
      div.innerHTML = `<img src="${img}" alt="${escapeHtml(label)}"/>
        <div class="badge">${escapeHtml(invite)}</div>
        <button class="like" type="button" aria-label="${t('likeLabel')}"><span>â¤ï¸</span><span class="like-count">${likes}</span></button>
        <div style="position:absolute;bottom:6px;left:6px;right:6px;background:rgba(0,0,0,0.55);color:white;font-size:12px;padding:4px 6px;border-radius:8px;">${escapeHtml(label)}${timeInfo? ' â€“ '+timeInfo: ''}</div>`;
      div.addEventListener('click', (e) => {
        if (e.target.closest('.like')) return;
        showLightbox(img, `${invite} â€“ ${label}`);
      });
      div.querySelector('.like').addEventListener('click', (e) => {
        e.stopPropagation();
        toggleLike(inviteKey, img, div.querySelector('.like'));
      });
      grid.appendChild(div);
    });
    col.appendChild(grid);
    columnsWrap.appendChild(col);
  });
}

const LIKES_KEY = 'defis_mariage_likes_v1';
function loadLikes() {
  try { const raw = localStorage.getItem(LIKES_KEY); return raw ? JSON.parse(raw) : {}; } catch { return {}; }
}
let likesDb = loadLikes();
const DEVICE_KEY = 'defis_mariage_device_id';
function getDeviceId() {
  let id = localStorage.getItem(DEVICE_KEY);
  if (!id) { id = Math.random().toString(36).slice(2); localStorage.setItem(DEVICE_KEY, id); }
  return id;
}
function makeImageId(inviteKey, imgData) { return `${inviteKey}:${imgData.slice(0,50)}`; }
function getLikesFor(inviteKey, imgData) {
  const id = makeImageId(inviteKey, imgData);
  const rec = likesDb[id];
  return rec && typeof rec.count === 'number' ? rec.count : 0;
}
function toggleLike(inviteKey, imgData, btnEl) {
  const id = makeImageId(inviteKey, imgData);
  const device = getDeviceId();
  if (!likesDb[id]) likesDb[id] = { count: 0, voters: {} };
  const rec = likesDb[id];
  if (rec.voters[device]) { // unlike
    rec.voters[device] = false;
    rec.count = Math.max(0, rec.count - 1);
    btnEl.classList.remove('liked');
  } else { // like
    rec.voters[device] = true;
    rec.count += 1;
    btnEl.classList.add('liked');
  }
  localStorage.setItem(LIKES_KEY, JSON.stringify(likesDb));
  const c = btnEl.querySelector('.like-count');
  if (c) c.textContent = String(rec.count);
}

function showLightbox(src, caption) {
  if (!lightboxEl) return;
  lightboxImg.src = src;
  lightboxCaption.textContent = caption || '';
  lightboxDownload.href = src;
  lightboxEl.classList.remove('hidden');
}

function hideLightbox() {
  if (!lightboxEl) return;
  lightboxEl.classList.add('hidden');
  lightboxImg.src = '';
}

function renderTopLikes() {
  const labelEl = document.getElementById('top-like-label');
  const countEl = document.getElementById('top-like-count');
  if (!labelEl || !countEl) return;
  let best = { count: 0, label: 'â€”' };
  for (const [inviteKey, arr] of Object.entries(uploads)) {
    (arr||[]).forEach((up) => {
      if (up && up.data && up.published) {
        const id = makeImageId(inviteKey, up.data);
        const rec = likesDb[id];
        const c = rec && rec.count ? rec.count : 0;
        if (c > best.count) best = { count: c, label: `${state.nameMap[inviteKey]||inviteKey} â€“ ${up.challengeLabel||''}` };
      }
    });
  }
  labelEl.textContent = best.label;
  countEl.textContent = String(best.count);
}

function renderPublicRanking() {
  const tbody = document.getElementById('public-ranking-tbody');
  const podium = document.getElementById('public-podium');
  if (!tbody || !podium) return;
  const rows = Object.keys(state.assignments).map((key) => {
    const display = state.nameMap[key] || key;
    const d = computeDurationMs(key);
    return { key, display, d };
  }).filter(r => r.d != null).sort((a,b) => a.d - b.d);
  tbody.innerHTML = '';
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(r.display)}</td><td>${formatDuration(r.d)}</td>`;
    tbody.appendChild(tr);
  });
  podium.innerHTML = '';
  const top = rows.slice(0,3);
  top.forEach((r, i) => {
    const div = document.createElement('div');
    div.className = 'step';
    div.innerHTML = `<h4>${i===0?'ðŸ¥‡':i===1?'ðŸ¥ˆ':'ðŸ¥‰'} ${escapeHtml(r.display)}</h4><div>${formatDuration(r.d)}</div>`;
    podium.appendChild(div);
  });
}

function hydrateChallengeFilter() {
  const select = document.getElementById('challenge-filter');
  if (!select) return;
  select.innerHTML = '';
  const labels = new Set();
  for (const [key, arr] of Object.entries(uploads)) {
    (arr||[]).forEach(up => { if (up && up.challengeLabel) labels.add(up.challengeLabel); });
  }
  const opts = Array.from(labels).sort();
  opts.forEach(l => {
    const o = document.createElement('option');
    o.value = l; o.textContent = l; select.appendChild(o);
  });
  const tabGen = document.getElementById('tab-general');
  const tabCh = document.getElementById('tab-by-challenge');
  const tabLikes = document.getElementById('tab-by-likes');
  const viewGen = document.getElementById('rank-general');
  const viewCh = document.getElementById('rank-by-challenge');
  const viewLikes = document.getElementById('rank-by-likes');
  if (tabGen) tabGen.addEventListener('click', () => {
    tabGen.classList.add('active'); tabCh.classList.remove('active'); tabLikes.classList.remove('active');
    viewGen.classList.remove('hidden'); viewCh.classList.add('hidden'); viewLikes.classList.add('hidden');
  });
  if (tabCh) tabCh.addEventListener('click', () => {
    tabCh.classList.add('active'); tabGen.classList.remove('active'); tabLikes.classList.remove('active');
    viewCh.classList.remove('hidden'); viewGen.classList.add('hidden'); viewLikes.classList.add('hidden');
    renderRankingByChallenge(select.value);
  });
  if (tabLikes) tabLikes.addEventListener('click', () => {
    tabLikes.classList.add('active'); tabGen.classList.remove('active'); tabCh.classList.remove('active');
    viewLikes.classList.remove('hidden'); viewGen.classList.add('hidden'); viewCh.classList.add('hidden');
    renderRankingByLikes();
  });
  select.addEventListener('change', () => renderRankingByChallenge(select.value));
}

function computeDurationForChallenge(inviteKey, label) {
  const [u0,u1] = getUploadsForInvite(inviteKey);
  const arr = [u0,u1];
  const filtered = arr.filter(up => up && up.challengeLabel === label && up.createdAt && up.approvedAt);
  if (filtered.length === 0) return null;
  const start = Math.min(...filtered.map(f => f.createdAt));
  const end = Math.max(...filtered.map(f => f.approvedAt));
  return Math.max(0, end - start);
}

function renderRankingByChallenge(label) {
  const tbody = document.getElementById('challenge-ranking-tbody');
  const podium = document.getElementById('challenge-podium');
  if (!tbody || !podium) return;
  const rows = Object.keys(state.assignments).map((key) => {
    const display = state.nameMap[key] || key;
    const d = computeDurationForChallenge(key, label);
    return { key, display, d };
  }).filter(r => r.d != null).sort((a,b) => a.d - b.d);
  tbody.innerHTML = '';
  rows.forEach((r, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(r.display)}</td><td>${formatDuration(r.d)}</td>`;
    tbody.appendChild(tr);
  });
  podium.innerHTML = '';
  rows.slice(0,3).forEach((r, i) => {
    const div = document.createElement('div');
    div.className = 'step';
    div.innerHTML = `<h4>${i===0?'ðŸ¥‡':i===1?'ðŸ¥ˆ':'ðŸ¥‰'} ${escapeHtml(r.display)}</h4><div>${formatDuration(r.d)}</div>`;
    podium.appendChild(div);
  });
}

function renderRankingByLikes() {
  const tbody = document.getElementById('likes-ranking-tbody');
  const podium = document.getElementById('likes-podium');
  if (!tbody || !podium) return;
  const items = [];
  for (const [inviteKey, arr] of Object.entries(uploads)) {
    const display = state.nameMap[inviteKey] || inviteKey;
    (arr||[]).forEach((up) => {
      if (up && up.data && up.published) {
        const id = makeImageId(inviteKey, up.data);
        const c = (likesDb[id] && likesDb[id].count) ? likesDb[id].count : 0;
        items.push({ display, challenge: up.challengeLabel||'', likes: c });
      }
    });
  }
  items.sort((a,b) => b.likes - a.likes);
  tbody.innerHTML = '';
  items.forEach((it, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${idx+1}</td><td>${escapeHtml(it.display)}</td><td>${escapeHtml(it.challenge)}</td><td>${it.likes}</td>`;
    tbody.appendChild(tr);
  });
  podium.innerHTML = '';
  items.slice(0,3).forEach((it, i) => {
    const div = document.createElement('div');
    div.className = 'step';
    div.innerHTML = `<h4>${i===0?'ðŸ¥‡':i===1?'ðŸ¥ˆ':'ðŸ¥‰'} ${escapeHtml(it.display)}</h4><div>${escapeHtml(it.challenge)} â€“ ${it.likes} â¤ï¸</div>`;
    podium.appendChild(div);
  });
}

function compressImageToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const maxSize = 1600; // Max width/height

        // 1. Resize the image while maintaining aspect ratio
        let { width, height } = img;
        if (width > height) {
          if (width > maxSize) {
            height *= maxSize / width;
            width = maxSize;
          }
        } else {
          if (height > maxSize) {
            width *= maxSize / height;
            height = maxSize;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      };
      img.onerror = reject;
      img.src = e.target.result;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function applyFrame(originalImage) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const frameImg = new Image();
            frameImg.onload = () => {
                ctx.drawImage(frameImg, 0, 0, img.width, img.height);
                resolve(canvas.toDataURL('image/jpeg', 0.9));
            };
            frameImg.onerror = reject;
            frameImg.src = state.frame;
        };
        img.onerror = reject;
        img.src = originalImage;
    });
}

async function openLiveCapture(slot) {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    showToast(t("cameraApiUnavailable"), "danger");
    return;
  }

  let stream = null;
  const overlay = document.createElement('div');
  
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    
    overlay.style.position = 'fixed'; 
    overlay.style.inset = '0'; 
    overlay.style.zIndex = '70'; 
    overlay.style.background = 'rgba(0,0,0,0.8)';
    overlay.innerHTML = `
      <div style="position:absolute;inset:0;display:grid;place-items:center;">
        <div style="background:#000;padding:8px;border-radius:12px;display:grid;gap:8px;max-width:92vw;">
          <video id="live-video" autoplay playsinline style="width:min(92vw,640px);height:auto;border-radius:8px;"></video>
          <div style="display:flex;gap:8px;justify-content:flex-end;">
            <button id="live-cancel" class="btn">${t('cancel')}</button>
            <button id="live-shoot" class="btn primary">${t('takePhoto')}</button>
          </div>
        </div>
      </div>`;
    document.body.appendChild(overlay);

    const video = overlay.querySelector('#live-video');
    video.srcObject = stream;

    const cleanup = () => {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
      }
      if (overlay.parentNode) {
        overlay.remove();
      }
    };

    overlay.querySelector('#live-cancel').addEventListener('click', cleanup);
    overlay.querySelector('#live-shoot').addEventListener('click', async () => {
      showLoading();
      try {
        const track = stream.getVideoTracks()[0];
        const imageCapture = 'ImageCapture' in window ? new ImageCapture(track) : null;
        let blob;

        if (imageCapture && imageCapture.takePhoto) {
          blob = await imageCapture.takePhoto();
        } else {
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);
          blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.92));
        }
        
        const file = new File([blob], 'live.jpg', { type: 'image/jpeg' });
        await handleImageSelected(slot, file);

      } catch (e) {
        showToast(t("captureImpossible"), "danger");
      } finally {
        cleanup();
        hideLoading();
      }
    });
  } catch (err) {
      console.error(t('cameraErrorPrompt'), err);
      showToast(t("cameraError"), "danger");
      if (stream) { stream.getTracks().forEach(t=>t.stop()); }
      if (overlay.parentNode) { overlay.remove(); }
  }
}

function renderAdminStats() {
  const statsParticipantsEl = document.getElementById('stats-participants');
  const statsPendingEl = document.getElementById('stats-pending');
  const statsPublishedEl = document.getElementById('stats-published');

  if (!statsParticipantsEl || !statsPendingEl || !statsPublishedEl) return;

  const participants = new Set(Object.keys(uploads));
  let pendingCount = 0;
  let publishedCount = 0;

  for (const arr of Object.values(uploads)) {
    (arr || []).forEach(up => {
      if (up && up.data) {
        if (up.published) {
          publishedCount++;
        } else if (!up.approved) {
          pendingCount++;
        }
      }
    });
  }

  statsParticipantsEl.textContent = participants.size;
  statsPendingEl.textContent = pendingCount;
  statsPublishedEl.textContent = publishedCount;
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
